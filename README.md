# 1. 레이어드 + 인터페이스 아키텍처 -> 클린 아키텍처 부분 도입
## 1. 초기 구조 (레이어드 + 인터페이스 아키텍처)

초기에는 전형적인 레이어드 아키텍처를 사용하여 기능 중심으로 구조화되어 있었습니다.

```
com.example.ecommerce.balance
├── api
├── controller
├── service
├── service.impl
├── repository
├── domain
├── dto
```


### 주요 특징
- 컨트롤러 → 서비스 → 레포지토리의 흐름
- 인터페이스와 구현체를 `service` / `service.impl` 및 `repository` / `repository.impl`로 분리
- `dto`, `domain` 폴더는 단일 계층에서 사용

---

## 2. 구조 리팩토링 (클린 아키텍처 원칙 일부 도입)

다음과 같은 기준으로 패키지 구조를 재편성 하였습니다.

```
com.example.ecommerce.balance
├── api
│ ├── controller
│ ├── dto
│ │ ├── request
│ │ ├── response
│ └── spec
├── application
├── domain
│ ├── model
│ ├── repository
│ └── service
├── infrastructure
│ └── persistence
│ ├── impl
│ └── jpa
```

### 변화 요약

```
| 항목 | Before | After | 변경 이유 |
|------|--------|-------|------------|
| **controller** | balance.controller | balance.api.controller | 외부 진입점을 api로 명확히 분리 |
| **dto** | balance.dto | balance.api.dto.request / response | 입력과 출력 DTO를 명확하게 분리 |
| **spec** | 없음 | balance.api.spec | Swagger용 API 명세 클래스 관리 |
| **서비스 인터페이스** | balance.service | balance.application | 유즈케이스로 명확히 정의 |
| **도메인 모델** | balance.domain | balance.domain.model | 핵심 비즈니스 객체만 위치 |
| **도메인 서비스** | balance.service | balance.domain.service | 도메인 정책 로직의 독립화 |
| **레포지토리 인터페이스** | balance.repository | balance.domain.repository | 인프라에 종속되지 않도록 분리 |
| **레포지토리 구현체** | balance.repository.impl | balance.infrastructure.persistence.impl | 구현은 외부 계층에 둠 |
| **JPA 인터페이스** | 없음 | balance.infrastructure.persistence.jpa | Spring Data JPA 전용 인터페이스 별도 관리 |
```
---

## 3. 설계 원칙 적용

- **의존성 역전 원칙 (DIP)**  
  - `domain.repository`는 `infrastructure`에 의존하지 않음
  - `BalanceJpaRepository`는 구현체에서만 참조됨

- **관심사 분리 (Separation of Concerns)**  
  - 요청/응답 DTO, 유즈케이스, 도메인, 영속성 구현이 명확히 분리됨

- **SOLID** 중 일부 원칙 적용  
  - SRP: 각각의 클래스와 패키지는 하나의 책임만 가지도록 분리
  - DIP: 인터페이스 의존 및 외부 구현체 분리

---

## 4. 장점

- 유지보수 및 테스트 용이
- 명확한 책임 분리
- 도메인 모델이 인프라 구현과 분리되어 재사용성과 확장성 증가



# 2. 클린 아키텍처를 적용하며 느낀 점

## 개요

어느 아키텍처로 진행할지 고민해봤는데 프로젝트의 사이즈와 현실적인 상황으로 봤을 때, 기존에 제가 가장 많이 사용해왔던 구조인 레이어드 + 인터페이스 아키텍처가 가장 적합하다고 생각했습니다.

처음부터 복잡한 구조를 가져가기보다는,
익숙한 방식으로 빠르게 개발을 진행하면서 필요할 때 구조를 개선해나가자는 생각도 있었습니다.

이번 Balance 도메인을 먼저 개발하면서 기존에 사용하던 '레이어드 + 인터페이스' 아키텍처 구조에서 클린 아키텍처를 일부 적용해봤습니다. 
처음에는 '레이어드 + 인터페이스' 아키텍처 구조만으로도 충분하다고 생각했지만,  
기능이 조금씩 늘어나고 연관된 로직이 얽히면서 점점 한계가 느껴졌습니다.

특히 단순한 CRUD가 아닌 잔액 충전, 사용, 이력 저장 등의 규칙이 섬세하게 요구되는 도메인이기 때문에,  
도메인 로직을 보다 명확하게 표현할 수 있는 구조가 필요했습니다.
그 과정에서 클린 아키텍처를 적용하게 됐고, 다음과 같은 기준과 목적을 가지고 패키지를 나누었습니다.

---

## 구현하면서 느낀 점

### 1. 도메인 중심 설계의 장점

도메인 모델이 핵심 로직을 책임지도록 구성하면서 코드의 응집도가 훨씬 높아졌습니다.
이전에는 모든 처리를 서비스 레이어에서 하다 보니 로직이 흩어지고 테스트도 어려웠는데,  
이제는 도메인 단위로 책임이 분리되고 테스트도 용이해졌습니다.

또한 반복되는 규칙이나 흐름이 생길 때마다 도메인 서비스로 분리해 재사용하게 되면서  
코드 가독성과 유지보수성이 좋아졌습니다.

---

### 2. 테스트 용이성

`repository` 인터페이스를 도메인 계층에 정의하고,  
실제 구현은 `infrastructure` 계층에 분리하면서 외부 의존성을 격리할 수 있었다.  
이로 인해 단위 테스트 시 JPA나 DB 없이 mock으로 도메인과 서비스 로직을 검증할 수 있어  
테스트 속도와 유연성이 확실히 개선되었습니다.
---

### 3. 의존성 방향에 대한 고민

클린 아키텍처에서는 도메인이 외부 기술에 의존하지 않아야 하므로,  
항상 의존성의 방향을 의식하게 되었습니다.

특히 DTO나 JPA Entity가 도메인 내부로 침투하지 않도록 노력했고,  
이로 인해 각 계층 간 변환 코드가 생기긴 했지만, 구조적으로는 더 명확해진 것 같습니다.

---

### 4. 아쉬운 점

- DTO와 도메인 간 변환 코드가 생각보다 많아졌습니다. 
  간단한 도메인에서는 괜찮지만, 변환 로직이 많아질 경우 반복되는 작업이 피로하게 느껴졌습니다.
  Mapper 클래스를 명확히 분리하거나, 변환 책임을 하나의 컴포넌트로 모으는 방식이 필요하다고 느꼈습니다.


---

## 마무리

클린 아키텍처를 처음부터 완벽하게 적용하는 건 어렵지만,  
그 방향성을 가지고 설계를 시작하니 코드가 도메인 중심으로 정리되어가는게 느껴졌습니다.

이번 경험을 통해 단순한 기술 도입이 아니라, 코드의 역할과 책임을 구분하는 관점에서 설계를 고민하게 되었고,  
앞으로 더욱 좋은 품질의 코드를 작성할 것 입니다!

